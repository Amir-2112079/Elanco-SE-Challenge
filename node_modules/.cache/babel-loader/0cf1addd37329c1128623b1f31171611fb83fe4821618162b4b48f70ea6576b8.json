{"ast":null,"code":"import _objectSpread from \"@babel/runtime-corejs3/helpers/objectSpread2\";\nimport _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";\nimport { eachOperation, opId } from './helpers/index.js';\nvar nullFn = function nullFn() {\n  return null;\n};\nvar normalizeArray = function normalizeArray(arg) {\n  return Array.isArray(arg) ? arg : [arg];\n}; // To allow stubbing of functions\n\nexport var self = {\n  mapTagOperations: mapTagOperations,\n  makeExecute: makeExecute\n}; // Make an execute, bound to arguments defined in mapTagOperation's callback (cb)\n\nexport function makeExecute() {\n  var swaggerJs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return function (_ref) {\n    var pathName = _ref.pathName,\n      method = _ref.method,\n      operationId = _ref.operationId;\n    return function (parameters) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var requestInterceptor = swaggerJs.requestInterceptor,\n        responseInterceptor = swaggerJs.responseInterceptor,\n        userFetch = swaggerJs.userFetch;\n      return swaggerJs.execute(_objectSpread({\n        spec: swaggerJs.spec,\n        requestInterceptor: requestInterceptor,\n        responseInterceptor: responseInterceptor,\n        userFetch: userFetch,\n        pathName: pathName,\n        method: method,\n        parameters: parameters,\n        operationId: operationId\n      }, opts));\n    };\n  };\n} // Creates an interface with tags+operations = execute\n// The shape\n// { apis: { [tag]: { operations: [operation]: { execute }}}}\n// NOTE: this is mostly for compatibility\n\nexport function makeApisTagOperationsOperationExecute() {\n  var swaggerJs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  // { apis: tag: operations: execute }\n  var cb = self.makeExecute(swaggerJs);\n  var tagOperations = self.mapTagOperations({\n    v2OperationIdCompatibilityMode: swaggerJs.v2OperationIdCompatibilityMode,\n    spec: swaggerJs.spec,\n    cb: cb\n  });\n  var apis = {}; // eslint-disable-next-line no-restricted-syntax, guard-for-in\n\n  for (var tag in tagOperations) {\n    apis[tag] = {\n      operations: {}\n    }; // eslint-disable-next-line no-restricted-syntax, guard-for-in\n\n    for (var op in tagOperations[tag]) {\n      apis[tag].operations[op] = {\n        execute: tagOperations[tag][op]\n      };\n    }\n  }\n  return {\n    apis: apis\n  };\n} // .apis[tag][operationId]:ExecuteFunction interface\n\nexport function makeApisTagOperation() {\n  var swaggerJs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var cb = self.makeExecute(swaggerJs);\n  return {\n    apis: self.mapTagOperations({\n      v2OperationIdCompatibilityMode: swaggerJs.v2OperationIdCompatibilityMode,\n      spec: swaggerJs.spec,\n      cb: cb\n    })\n  };\n}\n/**\n * Iterates over a spec, creating a hash of {[tag]: { [operationId], ... }, ...}\n * with the value of calling `cb`.\n *\n * `spec` is a OAI v2.0 compliant specification object\n * `cb` is called with ({ spec, operation, path, method })\n * `defaultTag` will house all non-tagged operations\n *\n */\n\nexport function mapTagOperations(_ref2) {\n  var spec = _ref2.spec,\n    _ref2$cb = _ref2.cb,\n    cb = _ref2$cb === void 0 ? nullFn : _ref2$cb,\n    _ref2$defaultTag = _ref2.defaultTag,\n    defaultTag = _ref2$defaultTag === void 0 ? 'default' : _ref2$defaultTag,\n    v2OperationIdCompatibilityMode = _ref2.v2OperationIdCompatibilityMode;\n  var operationIdCounter = {};\n  var tagOperations = {}; // Will house all tags + operations\n\n  eachOperation(spec, function (_ref3) {\n    var pathName = _ref3.pathName,\n      method = _ref3.method,\n      operation = _ref3.operation;\n    var tags = operation.tags ? normalizeArray(operation.tags) : [defaultTag];\n    tags.forEach(function (tag) {\n      if (typeof tag !== 'string') {\n        return;\n      }\n      tagOperations[tag] = tagOperations[tag] || {};\n      var tagObj = tagOperations[tag];\n      var id = opId(operation, pathName, method, {\n        v2OperationIdCompatibilityMode: v2OperationIdCompatibilityMode\n      });\n      var cbResult = cb({\n        spec: spec,\n        pathName: pathName,\n        method: method,\n        operation: operation,\n        operationId: id\n      });\n      if (operationIdCounter[id]) {\n        var _context;\n        operationIdCounter[id] += 1;\n        tagObj[_concatInstanceProperty(_context = \"\".concat(id)).call(_context, operationIdCounter[id])] = cbResult;\n      } else if (typeof tagObj[id] !== 'undefined') {\n        var _context2, _context3;\n\n        // Bump counter ( for this operationId )\n        var originalCounterValue = operationIdCounter[id] || 1;\n        operationIdCounter[id] = originalCounterValue + 1; // Append _x to the operationId\n\n        tagObj[_concatInstanceProperty(_context2 = \"\".concat(id)).call(_context2, operationIdCounter[id])] = cbResult; // Rename the first operationId\n\n        var temp = tagObj[id];\n        delete tagObj[id];\n        tagObj[_concatInstanceProperty(_context3 = \"\".concat(id)).call(_context3, originalCounterValue)] = temp;\n      } else {\n        // Assign callback result ( usually a bound function )\n        tagObj[id] = cbResult;\n      }\n    });\n  });\n  return tagOperations;\n}","map":{"version":3,"names":["_objectSpread","_concatInstanceProperty","eachOperation","opId","nullFn","normalizeArray","arg","Array","isArray","self","mapTagOperations","makeExecute","swaggerJs","arguments","length","undefined","_ref","pathName","method","operationId","parameters","opts","requestInterceptor","responseInterceptor","userFetch","execute","spec","makeApisTagOperationsOperationExecute","cb","tagOperations","v2OperationIdCompatibilityMode","apis","tag","operations","op","makeApisTagOperation","_ref2","_ref2$cb","_ref2$defaultTag","defaultTag","operationIdCounter","_ref3","operation","tags","forEach","tagObj","id","cbResult","_context","concat","call","_context2","_context3","originalCounterValue","temp"],"sources":["E:/Placement Tests/Elanco-Task/api-test/node_modules/swagger-client/es/interfaces.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime-corejs3/helpers/objectSpread2\";\nimport _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";\nimport { eachOperation, opId } from './helpers/index.js';\n\nvar nullFn = function nullFn() {\n  return null;\n};\n\nvar normalizeArray = function normalizeArray(arg) {\n  return Array.isArray(arg) ? arg : [arg];\n}; // To allow stubbing of functions\n\n\nexport var self = {\n  mapTagOperations: mapTagOperations,\n  makeExecute: makeExecute\n}; // Make an execute, bound to arguments defined in mapTagOperation's callback (cb)\n\nexport function makeExecute() {\n  var swaggerJs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return function (_ref) {\n    var pathName = _ref.pathName,\n        method = _ref.method,\n        operationId = _ref.operationId;\n    return function (parameters) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var requestInterceptor = swaggerJs.requestInterceptor,\n          responseInterceptor = swaggerJs.responseInterceptor,\n          userFetch = swaggerJs.userFetch;\n      return swaggerJs.execute(_objectSpread({\n        spec: swaggerJs.spec,\n        requestInterceptor: requestInterceptor,\n        responseInterceptor: responseInterceptor,\n        userFetch: userFetch,\n        pathName: pathName,\n        method: method,\n        parameters: parameters,\n        operationId: operationId\n      }, opts));\n    };\n  };\n} // Creates an interface with tags+operations = execute\n// The shape\n// { apis: { [tag]: { operations: [operation]: { execute }}}}\n// NOTE: this is mostly for compatibility\n\nexport function makeApisTagOperationsOperationExecute() {\n  var swaggerJs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  // { apis: tag: operations: execute }\n  var cb = self.makeExecute(swaggerJs);\n  var tagOperations = self.mapTagOperations({\n    v2OperationIdCompatibilityMode: swaggerJs.v2OperationIdCompatibilityMode,\n    spec: swaggerJs.spec,\n    cb: cb\n  });\n  var apis = {}; // eslint-disable-next-line no-restricted-syntax, guard-for-in\n\n  for (var tag in tagOperations) {\n    apis[tag] = {\n      operations: {}\n    }; // eslint-disable-next-line no-restricted-syntax, guard-for-in\n\n    for (var op in tagOperations[tag]) {\n      apis[tag].operations[op] = {\n        execute: tagOperations[tag][op]\n      };\n    }\n  }\n\n  return {\n    apis: apis\n  };\n} // .apis[tag][operationId]:ExecuteFunction interface\n\nexport function makeApisTagOperation() {\n  var swaggerJs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var cb = self.makeExecute(swaggerJs);\n  return {\n    apis: self.mapTagOperations({\n      v2OperationIdCompatibilityMode: swaggerJs.v2OperationIdCompatibilityMode,\n      spec: swaggerJs.spec,\n      cb: cb\n    })\n  };\n}\n/**\n * Iterates over a spec, creating a hash of {[tag]: { [operationId], ... }, ...}\n * with the value of calling `cb`.\n *\n * `spec` is a OAI v2.0 compliant specification object\n * `cb` is called with ({ spec, operation, path, method })\n * `defaultTag` will house all non-tagged operations\n *\n */\n\nexport function mapTagOperations(_ref2) {\n  var spec = _ref2.spec,\n      _ref2$cb = _ref2.cb,\n      cb = _ref2$cb === void 0 ? nullFn : _ref2$cb,\n      _ref2$defaultTag = _ref2.defaultTag,\n      defaultTag = _ref2$defaultTag === void 0 ? 'default' : _ref2$defaultTag,\n      v2OperationIdCompatibilityMode = _ref2.v2OperationIdCompatibilityMode;\n  var operationIdCounter = {};\n  var tagOperations = {}; // Will house all tags + operations\n\n  eachOperation(spec, function (_ref3) {\n    var pathName = _ref3.pathName,\n        method = _ref3.method,\n        operation = _ref3.operation;\n    var tags = operation.tags ? normalizeArray(operation.tags) : [defaultTag];\n    tags.forEach(function (tag) {\n      if (typeof tag !== 'string') {\n        return;\n      }\n\n      tagOperations[tag] = tagOperations[tag] || {};\n      var tagObj = tagOperations[tag];\n      var id = opId(operation, pathName, method, {\n        v2OperationIdCompatibilityMode: v2OperationIdCompatibilityMode\n      });\n      var cbResult = cb({\n        spec: spec,\n        pathName: pathName,\n        method: method,\n        operation: operation,\n        operationId: id\n      });\n\n      if (operationIdCounter[id]) {\n        var _context;\n\n        operationIdCounter[id] += 1;\n        tagObj[_concatInstanceProperty(_context = \"\".concat(id)).call(_context, operationIdCounter[id])] = cbResult;\n      } else if (typeof tagObj[id] !== 'undefined') {\n        var _context2, _context3;\n\n        // Bump counter ( for this operationId )\n        var originalCounterValue = operationIdCounter[id] || 1;\n        operationIdCounter[id] = originalCounterValue + 1; // Append _x to the operationId\n\n        tagObj[_concatInstanceProperty(_context2 = \"\".concat(id)).call(_context2, operationIdCounter[id])] = cbResult; // Rename the first operationId\n\n        var temp = tagObj[id];\n        delete tagObj[id];\n        tagObj[_concatInstanceProperty(_context3 = \"\".concat(id)).call(_context3, originalCounterValue)] = temp;\n      } else {\n        // Assign callback result ( usually a bound function )\n        tagObj[id] = cbResult;\n      }\n    });\n  });\n  return tagOperations;\n}"],"mappings":"AAAA,OAAOA,aAAa,MAAM,8CAA8C;AACxE,OAAOC,uBAAuB,MAAM,uDAAuD;AAC3F,SAASC,aAAa,EAAEC,IAAI,QAAQ,oBAAoB;AAExD,IAAIC,MAAM,GAAG,SAASA,MAAM,GAAG;EAC7B,OAAO,IAAI;AACb,CAAC;AAED,IAAIC,cAAc,GAAG,SAASA,cAAc,CAACC,GAAG,EAAE;EAChD,OAAOC,KAAK,CAACC,OAAO,CAACF,GAAG,CAAC,GAAGA,GAAG,GAAG,CAACA,GAAG,CAAC;AACzC,CAAC,CAAC,CAAC;;AAGH,OAAO,IAAIG,IAAI,GAAG;EAChBC,gBAAgB,EAAEA,gBAAgB;EAClCC,WAAW,EAAEA;AACf,CAAC,CAAC,CAAC;;AAEH,OAAO,SAASA,WAAW,GAAG;EAC5B,IAAIC,SAAS,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;EACtF,OAAO,UAAUG,IAAI,EAAE;IACrB,IAAIC,QAAQ,GAAGD,IAAI,CAACC,QAAQ;MACxBC,MAAM,GAAGF,IAAI,CAACE,MAAM;MACpBC,WAAW,GAAGH,IAAI,CAACG,WAAW;IAClC,OAAO,UAAUC,UAAU,EAAE;MAC3B,IAAIC,IAAI,GAAGR,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;MACjF,IAAIS,kBAAkB,GAAGV,SAAS,CAACU,kBAAkB;QACjDC,mBAAmB,GAAGX,SAAS,CAACW,mBAAmB;QACnDC,SAAS,GAAGZ,SAAS,CAACY,SAAS;MACnC,OAAOZ,SAAS,CAACa,OAAO,CAACzB,aAAa,CAAC;QACrC0B,IAAI,EAAEd,SAAS,CAACc,IAAI;QACpBJ,kBAAkB,EAAEA,kBAAkB;QACtCC,mBAAmB,EAAEA,mBAAmB;QACxCC,SAAS,EAAEA,SAAS;QACpBP,QAAQ,EAAEA,QAAQ;QAClBC,MAAM,EAAEA,MAAM;QACdE,UAAU,EAAEA,UAAU;QACtBD,WAAW,EAAEA;MACf,CAAC,EAAEE,IAAI,CAAC,CAAC;IACX,CAAC;EACH,CAAC;AACH,CAAC,CAAC;AACF;AACA;AACA;;AAEA,OAAO,SAASM,qCAAqC,GAAG;EACtD,IAAIf,SAAS,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;EACtF;EACA,IAAIe,EAAE,GAAGnB,IAAI,CAACE,WAAW,CAACC,SAAS,CAAC;EACpC,IAAIiB,aAAa,GAAGpB,IAAI,CAACC,gBAAgB,CAAC;IACxCoB,8BAA8B,EAAElB,SAAS,CAACkB,8BAA8B;IACxEJ,IAAI,EAAEd,SAAS,CAACc,IAAI;IACpBE,EAAE,EAAEA;EACN,CAAC,CAAC;EACF,IAAIG,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC;;EAEf,KAAK,IAAIC,GAAG,IAAIH,aAAa,EAAE;IAC7BE,IAAI,CAACC,GAAG,CAAC,GAAG;MACVC,UAAU,EAAE,CAAC;IACf,CAAC,CAAC,CAAC;;IAEH,KAAK,IAAIC,EAAE,IAAIL,aAAa,CAACG,GAAG,CAAC,EAAE;MACjCD,IAAI,CAACC,GAAG,CAAC,CAACC,UAAU,CAACC,EAAE,CAAC,GAAG;QACzBT,OAAO,EAAEI,aAAa,CAACG,GAAG,CAAC,CAACE,EAAE;MAChC,CAAC;IACH;EACF;EAEA,OAAO;IACLH,IAAI,EAAEA;EACR,CAAC;AACH,CAAC,CAAC;;AAEF,OAAO,SAASI,oBAAoB,GAAG;EACrC,IAAIvB,SAAS,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;EACtF,IAAIe,EAAE,GAAGnB,IAAI,CAACE,WAAW,CAACC,SAAS,CAAC;EACpC,OAAO;IACLmB,IAAI,EAAEtB,IAAI,CAACC,gBAAgB,CAAC;MAC1BoB,8BAA8B,EAAElB,SAAS,CAACkB,8BAA8B;MACxEJ,IAAI,EAAEd,SAAS,CAACc,IAAI;MACpBE,EAAE,EAAEA;IACN,CAAC;EACH,CAAC;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASlB,gBAAgB,CAAC0B,KAAK,EAAE;EACtC,IAAIV,IAAI,GAAGU,KAAK,CAACV,IAAI;IACjBW,QAAQ,GAAGD,KAAK,CAACR,EAAE;IACnBA,EAAE,GAAGS,QAAQ,KAAK,KAAK,CAAC,GAAGjC,MAAM,GAAGiC,QAAQ;IAC5CC,gBAAgB,GAAGF,KAAK,CAACG,UAAU;IACnCA,UAAU,GAAGD,gBAAgB,KAAK,KAAK,CAAC,GAAG,SAAS,GAAGA,gBAAgB;IACvER,8BAA8B,GAAGM,KAAK,CAACN,8BAA8B;EACzE,IAAIU,kBAAkB,GAAG,CAAC,CAAC;EAC3B,IAAIX,aAAa,GAAG,CAAC,CAAC,CAAC,CAAC;;EAExB3B,aAAa,CAACwB,IAAI,EAAE,UAAUe,KAAK,EAAE;IACnC,IAAIxB,QAAQ,GAAGwB,KAAK,CAACxB,QAAQ;MACzBC,MAAM,GAAGuB,KAAK,CAACvB,MAAM;MACrBwB,SAAS,GAAGD,KAAK,CAACC,SAAS;IAC/B,IAAIC,IAAI,GAAGD,SAAS,CAACC,IAAI,GAAGtC,cAAc,CAACqC,SAAS,CAACC,IAAI,CAAC,GAAG,CAACJ,UAAU,CAAC;IACzEI,IAAI,CAACC,OAAO,CAAC,UAAUZ,GAAG,EAAE;MAC1B,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;QAC3B;MACF;MAEAH,aAAa,CAACG,GAAG,CAAC,GAAGH,aAAa,CAACG,GAAG,CAAC,IAAI,CAAC,CAAC;MAC7C,IAAIa,MAAM,GAAGhB,aAAa,CAACG,GAAG,CAAC;MAC/B,IAAIc,EAAE,GAAG3C,IAAI,CAACuC,SAAS,EAAEzB,QAAQ,EAAEC,MAAM,EAAE;QACzCY,8BAA8B,EAAEA;MAClC,CAAC,CAAC;MACF,IAAIiB,QAAQ,GAAGnB,EAAE,CAAC;QAChBF,IAAI,EAAEA,IAAI;QACVT,QAAQ,EAAEA,QAAQ;QAClBC,MAAM,EAAEA,MAAM;QACdwB,SAAS,EAAEA,SAAS;QACpBvB,WAAW,EAAE2B;MACf,CAAC,CAAC;MAEF,IAAIN,kBAAkB,CAACM,EAAE,CAAC,EAAE;QAC1B,IAAIE,QAAQ;QAEZR,kBAAkB,CAACM,EAAE,CAAC,IAAI,CAAC;QAC3BD,MAAM,CAAC5C,uBAAuB,CAAC+C,QAAQ,GAAG,EAAE,CAACC,MAAM,CAACH,EAAE,CAAC,CAAC,CAACI,IAAI,CAACF,QAAQ,EAAER,kBAAkB,CAACM,EAAE,CAAC,CAAC,CAAC,GAAGC,QAAQ;MAC7G,CAAC,MAAM,IAAI,OAAOF,MAAM,CAACC,EAAE,CAAC,KAAK,WAAW,EAAE;QAC5C,IAAIK,SAAS,EAAEC,SAAS;;QAExB;QACA,IAAIC,oBAAoB,GAAGb,kBAAkB,CAACM,EAAE,CAAC,IAAI,CAAC;QACtDN,kBAAkB,CAACM,EAAE,CAAC,GAAGO,oBAAoB,GAAG,CAAC,CAAC,CAAC;;QAEnDR,MAAM,CAAC5C,uBAAuB,CAACkD,SAAS,GAAG,EAAE,CAACF,MAAM,CAACH,EAAE,CAAC,CAAC,CAACI,IAAI,CAACC,SAAS,EAAEX,kBAAkB,CAACM,EAAE,CAAC,CAAC,CAAC,GAAGC,QAAQ,CAAC,CAAC;;QAE/G,IAAIO,IAAI,GAAGT,MAAM,CAACC,EAAE,CAAC;QACrB,OAAOD,MAAM,CAACC,EAAE,CAAC;QACjBD,MAAM,CAAC5C,uBAAuB,CAACmD,SAAS,GAAG,EAAE,CAACH,MAAM,CAACH,EAAE,CAAC,CAAC,CAACI,IAAI,CAACE,SAAS,EAAEC,oBAAoB,CAAC,CAAC,GAAGC,IAAI;MACzG,CAAC,MAAM;QACL;QACAT,MAAM,CAACC,EAAE,CAAC,GAAGC,QAAQ;MACvB;IACF,CAAC,CAAC;EACJ,CAAC,CAAC;EACF,OAAOlB,aAAa;AACtB"},"metadata":{},"sourceType":"module","externalDependencies":[]}